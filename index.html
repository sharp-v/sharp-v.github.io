<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sharp-v.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="sharp-v&#39;s Blog">
<meta property="og:url" content="https://sharp-v.github.io/index.html">
<meta property="og:site_name" content="sharp-v&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="sharp-v">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://sharp-v.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>sharp-v's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">sharp-v's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sharp-v.github.io/2021/06/20/%E9%BB%91%E5%8C%A3%E5%AD%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sharp-v">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sharp-v's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/20/%E9%BB%91%E5%8C%A3%E5%AD%90/" class="post-title-link" itemprop="url">黑匣子</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-20 17:30:28" itemprop="dateCreated datePublished" datetime="2021-06-20T17:30:28+08:00">2021-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-26 16:22:04" itemprop="dateModified" datetime="2021-06-26T16:22:04+08:00">2021-06-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>反正没人听自己，<br>不如做一些有趣的事情</p>
<p>boring life</p>
<p>对人生感到迷茫，感觉根本没有未来一样，不知道怎么做，只是一昧地等待，等待着“末日”的到来。</p>
<p>不知道如何处理这些，于是就跑到这里来，看一看，回去还是一样的迷茫，不知如何，未来不过是个笑话罢了。。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sharp-v.github.io/2021/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sharp-v">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sharp-v's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">操作系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-19 12:19:10" itemprop="dateCreated datePublished" datetime="2021-06-19T12:19:10+08:00">2021-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-26 16:23:45" itemprop="dateModified" datetime="2021-06-26T16:23:45+08:00">2021-06-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><em><strong>(信息来源：操作系统课程ppt，网络和网络图片，个人修改 +个人总结或原句)</strong></em></p>
<h1 id="操作系统知识点总结"><a href="#操作系统知识点总结" class="headerlink" title="操作系统知识点总结"></a>操作系统知识点总结</h1><h2 id="一、操作系统基本概念"><a href="#一、操作系统基本概念" class="headerlink" title="一、操作系统基本概念"></a>一、操作系统基本概念</h2><p>OS: operatig system</p>
<h3 id="操作系统发展历史"><a href="#操作系统发展历史" class="headerlink" title="操作系统发展历史"></a>操作系统发展历史</h3><ol>
<li>人工操作阶段<br>真空管、插线板</li>
<li>批处理阶段<br>晶体管、批处理系统、穿孔卡片</li>
<li>形成阶段<br>集成电路、多道程序设计</li>
<li>成熟发展阶段 </li>
</ol>
<h3 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h3><ol>
<li><p>按处理器分类<br>a. 分时OS： 采用分配时间片的方法，一个CPU可以为多个用户服务<br>①所谓分时是指两个以上的事件按时间划分轮流使用某一个资源<br>②时间片是指分时的时间单位<br>③所谓分时系统时指多个用户通过联机终端设备时分使用同一台计算机的操作系统<br>b. 实时OS： 在较短的时间内及时响应用户要求并完成处理的OS</p>
</li>
<li><p>按适用面分<br>a. 专用OS：为特定应用目的定制<br>b. 通用OS：通用</p>
</li>
<li><p>按用户数量分<br>a. 单用户OS<br>b. 多用户OS</p>
</li>
<li><p>按任务处理方式分<br>a. 交互式OS<br>b. 批处理式OS</p>
<p>批处理(batch):<br>用户将一批作业提交给操作系统后就不再干预，由操作系统控制它们自动运行，such as widow,dos .bat<br>具体又分为：单道批处理系统、多道批处理系统<br>特征：用户脱机、作业批量处理<br>批处理操作系统把作业的吞吐量（单位事件里处理作业的个数）作为主要设计目标，同时兼顾作业的周转时间。<br>多道批处理系统的优点： 资源利用率高；系统吞吐量大</p>
<p>多道批处理系统的缺点：<br>①无交互能力，用户无法以“交互”方式控制作业的运行，对作业的执行过程中出现意外情况无法干预；<br>②平均周转时间长。作业的周转时间通常是几个小时或者几天。</p>
</li>
<li><p>按硬件环境和控制方式分<br>a. 集中式OS<br>b. 分布式OS</p>
</li>
</ol>
<h3 id="现代操作系统的基本特征"><a href="#现代操作系统的基本特征" class="headerlink" title="现代操作系统的基本特征"></a>现代操作系统的基本特征</h3><ol>
<li>并发性</li>
<li>共享性</li>
<li>虚拟性</li>
<li>不确定性</li>
</ol>
<h3 id="操作系统的基本功能性能评价和设计目标"><a href="#操作系统的基本功能性能评价和设计目标" class="headerlink" title="操作系统的基本功能性能评价和设计目标"></a>操作系统的基本功能性能评价和设计目标</h3><h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><p>文件管理<br>进程管理<br>存储器管理<br>设备管理<br>作业管理</p>
<h4 id="性能评价"><a href="#性能评价" class="headerlink" title="性能评价"></a>性能评价</h4><ol>
<li>系统效率<br>系统吞吐量<br>资源利用率<br>周转时间<br>响应时间</li>
<li>系统的可靠性、可维护性、可用性<br>可靠性R reliability<br>可维护性S serviceability<br>可用性A availability</li>
</ol>
<p>R=MTBF<br>S=MTTR<br>A=MTBF/(MTBF+MTTR)</p>
<ol start="3">
<li>其他方面<br>方便性<br>可移植性<br>安全性</li>
</ol>
<h4 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h4><p>方便用户使用<br>提供系统资源利用率<br>提高系统效率<br>扩大机器功能<br>构筑开放环境</p>
<h3 id="一些基本概率"><a href="#一些基本概率" class="headerlink" title="一些基本概率"></a>一些基本概率</h3><p>操作系统内核<br>内核是操作系统最基本的部分。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并且内核决定一个程序在什么时候对某部分硬件操作多长时间。内核的分类可分为单内核和双内核以及微内核。严格地说，内核并不是计算机系统中必要的组成部分。</p>
<p>为什么说内核不是计算机系统中必要的组成部分？</p>
<p>操作系统（operatig system，简称OS）是管理计算机硬件与软件资源的计算机程序。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。</p>
<p>计算机系统指用于数据库管理的计算机硬软件及网络系统。数据库系统需要大容量的主存以存放和运行操作系统、数据库管理系统程序、应用程序以及数据库、目录、系统缓冲区等，而辅存则需要大容量的直接存取设备。此外，系统应具有较强的网络功能。</p>
<p>内核是操作系统的内核。。。操作系统只是计算机系统(硬件)上的一个重要的软件，这个软件不一定要用于管理计算机硬件(内存管理、进程管理、文件管理等等都可以没有)，这个软件只要完成计算机系统的任务就行了，在或者这么说这个计算机系统上完全没有操作系统都是可以的，只要你会用。</p>
<p>那这里不如改成: 严格地说，操作系统内核不是计算机系统中的必要组成部分。<br>在“内核”前面加上“操作系统”，以表示强调，不然感觉原句略微装逼。</p>
<p>我这个普通人认为操作系统内核是操作系统的必要的组成部分，而且是核心部分。</p>
<h4 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h4><p>启动<br>BIOS -&gt; UEFI  （这里又是一大块，麻烦）<br>MBR GPT<br>HDD SSD</p>
<p>CPU<br>内核模式 特权指令+非特权指令<br>用户模式 非特权指令<br>访管指令：从用户模式切换到内核模式，内核模式完成后，从内核模式切换的到用户模式<br>中断、保护现场  中断优先级<br>通道、DMA   通道处理器即PCH(南桥)，北桥在CPU内部</p>
<h4 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h4><h5 id="程序员接口"><a href="#程序员接口" class="headerlink" title="程序员接口"></a>程序员接口</h5><p>操作系统为用户提供的各种操作命令，用户可利用这些操作命令来组织作业的工作流程和控制作业的执行。操作员接口包括脱机用户接口和联机用户接口两大类。</p>
<p><strong>作业</strong>:<br>把用户要求计算机完成的一个计算过程或者一次事务的处理过程称为一个作业。<br>作业是用户向计算机系统提交工作的基本单位。<br>作业的几个步骤：<br>编辑、编译、链接、运行</p>
<p>按作业的处理方式的不同分：<br>脱机工作：指用户不能直接与计算机系统交互，中间通过操作员干预的作业。<br>联机工作：指用户和计算机系统直接交互，用户通过终端或者控制台命令或者菜单图标等方式控制作业的运行。</p>
<h5 id="操作员接口"><a href="#操作员接口" class="headerlink" title="操作员接口"></a>操作员接口</h5><p>程序员接口由一组系统调用（System Call）组成。程序员接口是操作系统专门为用户程序设置的，允许用户程序调用操作系统的服务和功能，也是用户程序获得操作系统服务的唯一途径。</p>
<p><strong>系统调用（系统功能调用）</strong><br>用户在程序中能用访管指令区调用的由操作系统提供的子程序，其中每个子程序完成了一个特定的功能。</p>
<p><strong>系统调用和标准库函数的区别</strong>：</p>
<ol>
<li>标准库函数更用户自己编写的函数时一个层次上的东西</li>
<li>都是建立在API函数的基础之上</li>
<li>API函数中含有访管指令，会跳到内核中对应的内核函数入口去执行</li>
<li>widows、liux系统的API是C语言形式的，dos系统的API是汇编形式的，所以省去了API函数这一层，而是在用程序中直接调用访管指令IT</li>
</ol>
<p><strong>系统调用传递参数的方法</strong></p>
<ol>
<li>由访管指令或陷入指令自带参数。有直接参数和间接参数两种。例如UIX系统。(参数还是在内存中的)</li>
<li>通过CPU的通用寄存器传递参数，或在内存的一个块或表中存放参数，其首地址送入寄存器，实现参数传递。例如DOS系统。</li>
<li>在内存中开辟专用堆栈区域传递参数。</li>
</ol>
<p>系统调用与一般过程调用的区别</p>
<ol>
<li><p>运行的系统状态不同<br> 一般过程都是全是用户态或者全是内核态<br> 系统调用式通过访管指令或者终端从用户态进入内核态，完成调用后，回到用户态</p>
</li>
<li><p>进入的方式不同</p>
</li>
<li><p>调用的方式不同</p>
</li>
</ol>
<h2 id="二、处理器调度与调度算法"><a href="#二、处理器调度与调度算法" class="headerlink" title="二、处理器调度与调度算法"></a>二、处理器调度与调度算法</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="历史（哎又是历史）"><a href="#历史（哎又是历史）" class="headerlink" title="历史（哎又是历史）"></a>历史（哎又是历史）</h4><h5 id="单道程序系统"><a href="#单道程序系统" class="headerlink" title="单道程序系统"></a>单道程序系统</h5><p>在早期的单道程序系统中，一台计算机一次只能处理一个用户作业。机器的执行是按照用户编写的程序顺序执行的。</p>
<p><strong>单道程序系统特点：</strong></p>
<ol>
<li>程序执行的顺序性。</li>
<li>程序环境的封闭性。</li>
<li>程序执行结果的确定性。</li>
<li>计算过程的可再现性。</li>
</ol>
<h5 id="多道程序系统"><a href="#多道程序系统" class="headerlink" title="多道程序系统"></a>多道程序系统</h5><p>现代计算机系统普遍支持资源共享和多道程序设计。这样，一台计算机可以同时运行多个作业，这些作业在执行过程中有部分时间上的重叠。</p>
<p>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</p>
<p><img src="/2021/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/images/image-20210621173409811.png" alt="image-20210621173409811"></p>
<p>并发(cocurrecy)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p>
<p>对于任何一个作业I，其输入操作Ii、计算操作Ci、打印操作Pi这三者必须顺序执行，但对个作业来说，则有可能并发执行。</p>
<img src="  images\image-20210621170713229.png" alt="image-20210621170713229" style="zoom:50%;" />



<p><strong>多道程序系统特点：</strong></p>
<ol>
<li>失去了程序的封闭性和可再现性。</li>
<li>程序和机器执行程序的活动不再一一对应。</li>
<li>并发执行的程序存在着相互制约的关系</li>
</ol>
<p>两种制约方式：</p>
<ol>
<li>间接制约方式。<br>这是由于竞争相同资源而引起的，得到资源的程序段可以投入运行，而得不到资源的程序段就是暂时等待，直至获得可用资源时再继续运行。</li>
<li>直接制约方式。<br>这通常是在那些逻辑上相关的程序段之间发生的。一般是由于各种程序段要求共享信息引起的。</li>
</ol>
<p>多道程序环境下，程序的并发执行代替了程序的顺序执行，资源共享和竞争又导致并发程序之间的相互制约性，从而出现了许多新的特征和新的活动规律。<br>“程序”这个静态概念已不能如实反映和描述多道程序环境下程序并发执行的新特性，因此有必要引入一个能确切描述并反映并发过程的新概念——进程。 </p>
<h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><p>进程是一个可并发执行的具有独立功能的程序在某个数据集合上的一次动态执行过程，也是操作系统进行资源分配和保护的基本单位。</p>
<p>其他定义：（都类似的）<br>进程是可以并发执行的计算。<br>进程是一个程序与其数据一道通过处理机执行所发身生的活动。<br>进程是一个数据结构及在其上进行加工处理的过程。<br>进程是一个具有独立功能的程序在一个数据集合上的运行过程，它是系统进行资源分配和调度的基本单位。 </p>
<h4 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h4><p><strong>进程实体＝程序段代码段＋数据段＋PCB</strong></p>
<p><strong>进程控制块PCB （process cotrol block）</strong><br>进程控制块是进程存在的标志，当系统或父进程创建一个进程时，实际上就是为其建立一个进程控制块。<br>进程控制块既能标识进程的存在，又能刻画出进程的动态特征，它是一个进程仅有的被系统真正感知的部分。</p>
<p><strong>进程控制块PCB</strong>主要包含三类信息：进程标识信息、现场信息、控制信息</p>
<p><strong>标识信息</strong><br>用于唯一地标识一个进程，包括由用户使用的外部标识符和被系统使用的内部标识号<br>常用的标识信息有：<br>进程标识符<br>父进程的标识符<br>用户进程名<br>用户组名等</p>
<p><strong>现场信息</strong><br>保留进程运行时存放在处理器现场中的各种信息，进程让出处理器时必须把处理器现场信息保存到PCB中，当该进程重新恢复运行时也应恢复处理器现场。<br>现场信息包括通用寄存器内容、控制寄存器内容、用户堆栈指针、系统堆栈指针等</p>
<p><strong>控制信息</strong><br>①进程调度相关信息，如进程状态、等待事件和等待原因、进程优先级、队列指针等；<br>②进程组成信息，如正文段(即代码段)指针、数据段指针;<br>③进程间通信相关信息，如消息队列指针、信号量等互斥和同步机制；<br>④进程在二级存储器内的地址信息；<br>⑤CPU资源的占用和使用信息，如时间片余量、进程己占用时间、进程己执行时间总和，记帐信息；<br>⑥进程特权信息，如在内存访问和处理器状态方面的特权<br>⑦资源清单，包括进程所需全部资源、已经分得资源，如主存资源、I/O设备、打开文件表等。</p>
<h4 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h4><ol>
<li><p>动态性</p>
<p>动态性是进程最重要的特征。</p>
<p>动态性表现在进程是由“创建”而产生，由“调度”而执行，因得不到资源而暂停执行，即阻塞，最后由“撤消”而消亡。</p>
<p>可见进程具有一定的生命期。</p>
</li>
<li><p>并发性</p>
<p>进程的多个实体同存于内存中，能在一段时间内同时运行。这样就保证了一个进程的程序能和其它进程的程序并发执行。</p>
</li>
<li><p>独立性</p>
<p>进程实体是能独立运行的单位，它是系统中独立获得资源和独立调度的基本单位。</p>
</li>
<li><p>异步性</p>
<p>进程间是以各自独立的、不可预知的速度向前推进，即按异步方式运行。这一特性导致程序执行的不可再现性。</p>
</li>
<li><p>结构性</p>
<p>进程实体是有结构的，它由程序段、数据段和进程控制块三部分组成。这三部分也称“进程映像”。</p>
</li>
<li><p>共享性</p>
<p>多个进程可以共享系统中的资源。</p>
</li>
<li><p>制约性</p>
<p>并发执行的进程之间可能存在相互制约关系。</p>
</li>
</ol>
<h4 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h4><ol>
<li><p>程序是一组有序的指令集合，是一种静态的概念；进程是程序的一次执行，属于一种动态的概念。即进程是程序执行的动态过程，而程序是进程运行的静态文本。程序与进程的关系就好比“人体”与“人生”的关系一样。</p>
</li>
<li><p>进程与程序并非是一一对应的，一个相同的程序运行在不同的数据集合上就构成不同的进程。即一个进程可以执行一个或几个程序(uix行exec，widows不行)；反之，同一个程序可能由几个进程同时执行。</p>
</li>
<li><p>程序可以作为一种软件资料长期保存，但进程是有生命期的。</p>
</li>
<li><p>进程具有并发性，它能与其它进程并发执行；而一般的程序不具有这种明显的特性。</p>
</li>
<li><p>并发进程之间可能存在相互制约关系。 </p>
</li>
</ol>
<h4 id="作业与进程的关系"><a href="#作业与进程的关系" class="headerlink" title="作业与进程的关系"></a>作业与进程的关系</h4><p>作业是任务实体，进程是完成任务的执行实体；</p>
<p>没有作业任务，进程无事可干，没有进程，作业任务没法完成。</p>
<p>一个作业任务是由多个进程共同完成的。作业概念更多地用在批处理操作系统中，而进程则可以用在各种多道程序设计系统。</p>
<h3 id="进程的状态及其转换"><a href="#进程的状态及其转换" class="headerlink" title="进程的状态及其转换"></a>进程的状态及其转换</h3><h4 id="进程的三个状态"><a href="#进程的三个状态" class="headerlink" title="进程的三个状态"></a>进程的三个状态</h4><img src="  images\image-20210621174349538.png" alt="image-20210621174349538" style="zoom:50%;" />

<ol>
<li> 就绪态→运行态：CPU空闲时，系统按一种策略选择一个就绪进程，让它占用CPU，这个被选中的进程就从就绪变成运行状态。</li>
<li> 运行态→阻塞态：进程在运行过程中因I/O或等待使用资源或某事件的发生会从运行变成阻塞状态。</li>
<li> 阻塞态→就绪态：阻塞进程的I/O完成或资源得到满足或事件发生时会从阻塞变成就绪状态。</li>
<li> 运行态→就绪态：正在CPU上运行的进程因时间片用完了或系统出现了更高优先级的就绪进程而不得不放弃CPU从运行变成就绪状态。 </li>
</ol>
<h4 id="处理机的多级调度策略"><a href="#处理机的多级调度策略" class="headerlink" title="处理机的多级调度策略"></a>处理机的多级调度策略</h4><p>1.<strong>高级调度</strong>（又称宏观调度或作业调度）</p>
<p>高级调度的主要功能是根据一定的算法，从输入的一批作业中选出若干个作业，并为选中的作业分配必要的资源（如内存、外设等）、建立相应的用户作业进程以及为其服务的系统进程(如输入、输出进程)，然后把它们的程序和数据调入内存，等待进程调度程序对其进行调度，作业完成后负责回收系统资源。</p>
<p>2.<strong>中级调度</strong>（又称交换调度）</p>
<p>为了使内存中同时存放的进程数目不至于太多，有时就需要把某些进程从内存中移到外存上，以减少多道程序的数目，为此设立了中级调度。</p>
<p>特别在采用虚拟存储技术的系统或分时系统中，往往增加中级调度。</p>
<p>中级调度的功能是在内存使用情况紧张时，将一些暂时不能运行的进程从内存兑换到外存上等待，当以后内存有足够的空闲空间时，再将适合的进程重新换入内存，等待进程调度。</p>
<p>引入中级调度的主要目的是为了起到平滑和调整系统负荷、提高内存的利用率和系统吞吐量的作用，它实际上就是存储器管理中的兑换功能。</p>
<p>3.<strong>低级调度</strong>（又称微观调度或进程调度）</p>
<p>低级调度（即进程调度）的主要功能是根据一定的算法将CPU分派给就绪队列中的一个进程，由它实现进程间的切换。进程调度的运行频率很高，在分时系统中往往几十毫秒就要运行一次。进程调度是操作系统中最基本的一种调度，是操作系统最为核心的部分，进程调度策略的优劣直接影响到整个系统的性能。</p>
<h4 id="进程调度的方式和时机"><a href="#进程调度的方式和时机" class="headerlink" title="进程调度的方式和时机"></a>进程调度的方式和时机</h4><ol>
<li> 进程调度方式</li>
</ol>
<p>   非抢占式（非剥夺式）调度</p>
<p>   抢占式（剥夺式）调度</p>
<ol start="2">
<li> 进程调度的时机</li>
</ol>
<p>   当前运行进程执行结束而终止，或因等待某个事件的完成而无法继续执行，需要启动进程调度程序来选择一个新的就绪进程运行；</p>
<p>   在抢占式调度系统中，就绪队列中出现了优先级更高的进程，或当前运行进程的时间片已经用完，需要剥夺当前运行进程的CPU使用权，并将其分配给更高优先级的进程或时间片轮转的下一个就绪进程。</p>
<h3 id="常见的作业调度算法"><a href="#常见的作业调度算法" class="headerlink" title="常见的作业调度算法"></a>常见的作业调度算法</h3><ol>
<li><p>先来先服务调度算法 FCFS</p>
</li>
<li><p>最短作业优先调度算法 SJF</p>
</li>
<li><p>响应比高者优先的算法 HRRF</p>
<p>作业的响应时间比Rp定义为：</p>
<p>Rp=作业的响应时间TX/作业的执行时间TZ</p>
<p>因为：TX=作业的等待时间TD+作业的执行时间TZ</p>
<p>所以：Rp =  TX/ TZ =（ TD +TZ）/TZ </p>
<p>​                 = 1 + (作业的等待时间TD /作业的执行时间TZ)</p>
</li>
<li><p>优先级调度算法</p>
</li>
<li><p>均衡调度算法</p>
</li>
</ol>
<h3 id="常见的进程调度算法"><a href="#常见的进程调度算法" class="headerlink" title="常见的进程调度算法"></a>常见的进程调度算法</h3><ol>
<li><p>先来先服务算法</p>
</li>
<li><p>短进程优先算法</p>
</li>
<li><p>优先级算法</p>
</li>
<li><p>时间片轮转算法</p>
</li>
<li><p>多队列轮转调度算法</p>
</li>
<li><p>多级反馈队列调度算法</p>
</li>
<li><p>实时调度算法</p>
</li>
<li><p>其他进程调度算法</p>
</li>
</ol>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="1-为什么要引入线程的概念"><a href="#1-为什么要引入线程的概念" class="headerlink" title="1.为什么要引入线程的概念"></a>1.为什么要引入线程的概念</h4><p>操作系统中引入进程的目的是为了使多个程序并发执行，改善资源的利用率以及提高系统的吞吐量；</p>
<p>但是，进程给并发程序设计效率带来下列问题：</p>
<p>进程切换开销大</p>
<p>进程通信代价大(因为不同的地址空间)</p>
<p>进程之间的并发性粒度较粗，并发度不高</p>
<p>不适合并行计算和分布并行计算的要求</p>
<p>不适合客户/服务器计算的要求。</p>
<h4 id="2-多线程编程的优点"><a href="#2-多线程编程的优点" class="headerlink" title="2.多线程编程的优点"></a>2.多线程编程的优点</h4><p>（1）响应度高</p>
<p>（2）资源共享</p>
<p>（3）经济</p>
<h4 id="3-单线程进程结构和多线程进程结构"><a href="#3-单线程进程结构和多线程进程结构" class="headerlink" title="3.单线程进程结构和多线程进程结构"></a>3.单线程进程结构和多线程进程结构</h4><p>（1）单线程进程结构</p>
<p>   在单线程的进程模型中（即没有线程概念的进程），进程由进程控制块（PCB），用户地址空间（包括程序段和数据段）以及在进程执行中管理调用、返回行为的用户堆栈和系统堆栈组成的。</p>
<img src="  images\image-20210621214027015.png" alt="image-20210621214027015" style="zoom:50%;" />

<p>（2）多线程进程结构</p>
<p>​    线程是操作系统进程中能够独立执行的实体（控制流），是处理器调度和分派的基本单位。线程是进程的组成部分，每个进程内允许包含多个并发执行的实体（控制流），这就是多线程。</p>
<p>在多线程环境下，进程是操作系统中进行保护和资源分配的基本单位。它具有：</p>
<ol>
<li><p>一个虚拟地址空间，用来容纳进程的映像；</p>
</li>
<li><p>对处理器、其它(通信的)进程、文件和I/O资源等的存取保护机制。</p>
</li>
<li><p>在多线程环境中，进程仍然有一个进程控制块和用户地址空间。但每个线程都有自己独立的堆栈和线程控制块。</p>
</li>
<li><p>进程中的所有线程共享该进程的资源，它们驻留在同一块地址空间中，并且可以访问到相同的数据。当一个线程改变了内存中某个单元的数据时，其它线程在访问该数据单元时会看到变化后的结果。因此线程之间的通信变得更加简单，容易。</p>
</li>
</ol>
<img src="  images\image-20210621214622191.png" alt="image-20210621214622191" style="zoom:50%;" />



<h4 id="4-线程与进程的比较"><a href="#4-线程与进程的比较" class="headerlink" title="4.线程与进程的比较"></a>4.线程与进程的比较</h4><ol>
<li><p>调度</p>
<p>在引入线程的操作系统中，把线程作为调度和分派CPU的基本单位，而把进程作为资源分配的基本单位，使传统进程的两个属性分开，线程可以轻装运行，从而可以显著地提高系统地并发程度。</p>
<p>在同一个进程中，线程的切换不会引起进程的切换，只有当从一个进程中的线程切换到另一个进程中的线程时，才会引起进程的切换。</p>
<p>由于系统调度的基本单位是线程而不是进程，所以，每当创建一个进程时，至少要同时为该进程创建一个线程，否则该进程无法被调度执行。</p>
</li>
<li><p>并发性</p>
<p>在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间也可以并发执行，因而操作系统具有更好的并发性。</p>
<p>例如在一个没有引入线程的单处理机系统中，若仅设计了一个文件服务进程，当该进程由于某种原因被阻塞时，用户的文件服务请求就得不到响应。在引入线程的操作系统中，可以在一个文件服务进程中设计多个服务线程，当第一个线程被阻塞时，文件服务进程中的第二个线程可以继续执行；当第二个线程被阻塞时，第三个线程可以继续执行，从而显著地提高了文件服务的质量和系统的吞吐量。</p>
</li>
<li><p>拥有资源</p>
<p>不论是传统的操作系统，还是具有线程的操作系统，进程都是拥有资源的独立单位。</p>
<p>一般地说，线程自己不用有系统资源（只有少量的必不可少的资源），但它可以访问其隶属进程的资源。也就是说，一个进程的代码段、数据段及系统资源，如打开的文件、I/O设备等，可供同一进程中的所有线程共享。</p>
</li>
<li><p>系统开销</p>
<p>进程切换的开销远远大于线程切换的开销。此外，由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，变得非常容易。</p>
<p>在有些操作系统中，线程的切换、同步和通信都无须操作系统内核的干预。</p>
</li>
</ol>
<h4 id="5-线程的状态及其转换"><a href="#5-线程的状态及其转换" class="headerlink" title="5.线程的状态及其转换"></a>5.线程的状态及其转换</h4><p>线程的基本状态有：运行、就绪和阻塞。</p>
<p>但是，挂起状态对线程是没有意义的。如果进程挂起后被对换出主存，则它的所有线程因共享了进程的地址空间，也必须全部对换出去。</p>
<h4 id="6-线程的分类"><a href="#6-线程的分类" class="headerlink" title="6.线程的分类"></a>6.线程的分类</h4><p>对于进程来讲，无论它是系统进程还是用户进程，在进行切换时都要依赖于内核中的进程调度程序。所以，内核是感知进程存在的，在内核支持下进行进程切换。</p>
<p>而对于线程则不然，我们根据线程的切换是否依赖于内核把线程分成三类：</p>
<p> 用户级线程(ULT,user level thread)、内核级线程(KST,kernel support thread)和混合式线程</p>
<h4 id="7-线程的实现"><a href="#7-线程的实现" class="headerlink" title="7.线程的实现"></a>7.线程的实现</h4><h5 id="（1）内核级线程的实现思想"><a href="#（1）内核级线程的实现思想" class="headerlink" title="（1）内核级线程的实现思想"></a>（1）内核级线程的实现思想</h5><p>  在仅有内核级线程的系统中，有关线程管理的所有工作都是由内核来完成的。应用程序若要使用线程，只有通过由内核提供的应用程序编程接口（API）。</p>
<p>  任何应用程序都可以设计成多线程的程序，在一个进程内可以创建多个线程。操作系统内核负责保存进程的上下文环境信息，同时也为该进程的所有线程保存它们的上下文环境信息。</p>
<p>  系统的调度是基于线程的，也就是说，处理机的切换是以线程为单位进行的。</p>
<p><strong>内核级线程的主要优点：</strong></p>
<p> 1）如果进程中的一个线程被阻塞，内核可以调度同一个进程中的另一个就绪线程执行。</p>
<p> 2）在多处理机环境中，内核可以同时把同一个进程的多个线程分配到多个处理机上；</p>
<p> 3）内核本身也可以设计成多线程。</p>
<p><strong>内核级线程的主要缺点：</strong></p>
<p>  相对于用户级线程，内核级线程的主要缺点是，在同一个进程中把控制权从一个线程切换给另一个线程需要内核的状态转换（即用户态到核心态的转换），所以内核级线程的创建和管理通常要慢于用户级线程的创建和管理。</p>
<h5 id="（2）用户级线程的实现思想"><a href="#（2）用户级线程的实现思想" class="headerlink" title="（2）用户级线程的实现思想"></a>（2）用户级线程的实现思想</h5><p>用户级线程只存在于用户层，线程的创建、撤销及切换都不利用内核的系统调用实现，因而这种线程与内核无关，内核也不知道这种线程的存在。</p>
<p>纯ULT设施中，任何应用程序均需通过线程库进行程序设计，再与线程库连接后运行来实现多线程。</p>
<p>线程库是一个ULT管理的例行程序包，其中包含用于创建和撤销线程的例程、在线程之间传递消息和数据的例程、线程调度以及保存和恢复线程的代码。实质上线程库是线程的运行支撑环境。</p>
<p><strong>用户级线程的主要优点：</strong></p>
<p>1） 线程切换不需要系统状态的转换。</p>
<p>由于所有用户级线程的管理都在一个进程的用户地址空间中进行，用户级线程的切换不需要内核模式的特权。因此，进程也不需要为了线程的切换而转换到核心态，线程切换时进程仍然在用户态下运行，这就节省了系统从核心态到用户态或从用户态到核心态转换的时间和空间开销。</p>
<p>2） 每个进程可以使用专门的线程调度算法来调度线程。</p>
<p>对于应用进程来说，根据程序本身的特点，有的可能比较适合使用简单的时间片调度算法，有的则可能比较适合使用基于优先级的调度算法。</p>
<p>每个进程可以使用适合于自己的线程调度算法，而与其它进程无关，更不会干扰底层的操作系统调度程序。</p>
<p>3）用户级线程可以在任何操作系统中运行，不需要对底层操作系统内核进行修改。</p>
<p>  因为用户级线程不需要操作系统的支持，它的创建，撤销及切换是用自己的线程库来实现的，所以，用户级线程可以在任何操作系统中运行，不需要对底层操作系统内核进行修改。</p>
<p>线程库是一组供所有应用进程共享的应用级实用程序。</p>
<p><strong>用户级线程的不足：</strong></p>
<p>1）在典型的操作系统中，许多系统调用，如I/O操作会引起进程阻塞，当一个用户级线程调用一个系统调用时，系统认为是这个线程所在进程的行为，因此该进程被阻塞，从而导致该进程中的所有用户级线程此时都不能继续执行。</p>
<p>2）在只使用用户级线程的系统中，一个多线程的应用程序不能利用多处理机技术。内核一次把一个进程分配给一个处理机，因此一个进程中只有一个线程可以执行，即使其它处理机都空闲，该进程中的其它线程也不能执行。 </p>
<h5 id="（3）混合式线程的实现思想"><a href="#（3）混合式线程的实现思想" class="headerlink" title="（3）混合式线程的实现思想"></a>（3）混合式线程的实现思想</h5><p>​    混合系统中，内核支持KLT多线程的建立、调度和管理，也提供线程库，允许应用程序建立、调度和管理ULT。应用程序的多个ULT映射成一些KLT，程序员可按应用需要和机器配置调整KLT数目，以达到较好效果。 </p>
<h3 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>两个线程之间有同步关系，就是说两个线程之间有相互协作关系、相互配合关系</p>
<p>两个线程之间有互斥关系，就是说两个线程之间有相互竞争关系、相互排挤关系。</p>
<p>临界资源(Critical Resource)</p>
<p>把一次只允许一个进程使用的资源称为临界资源。</p>
<p>临界区(Critical section)</p>
<p>把每个进程中访问临界资源的那段代码称为临界区。</p>
<p>即临界区是指对临界资源实施操作的程序代码段。</p>
<p>相关临界区是指并发进程中涉及相同临界资源的临界区。</p>
<p>显然，相关临界区必须互斥执行。</p>
<p>相关临界区的管理原则</p>
<p>（1）对于临界区的协调的准则是：</p>
<p>​    ①当有若干个进程同时要求进入临界区时，应在有限时间内使一个进程进入(两个司机可以互不相让，但交警必须分出高低)</p>
<p>​    ②每次最多有一个进程处于相关临界区内</p>
<p>​    ③进程在临界区内应逗留有限时间(人家要是进去偏不出来你os还有啥办法？这是程序员的责任！)</p>
<p>（2）遵循以上准则，   得到临界区的调度原则是：</p>
<p>同步机制应遵循的准则</p>
<p>（1）空闲让进。无进程处于临界区时意味着临界资源处于空闲状态，这时若有进程要求进入临界区应立即允许进入。</p>
<p>（2）忙则等待。当已有进程进入其临界区时则意味着某临界资源正在使用，所有其他欲访问该临界资源的进程试图进入各自临界区时必须等待，以保证各进程互斥地进入访问相同临界资源的临界区。</p>
<p>（3）有限等待。若干进程要求进入访问同一临界资源的临界区时，应在有限时间内使一进程进入临界区，即不应出现各进程相互等待而都无法进入临界区的情况。</p>
<p>（4）让权等待。当进程不能进入其临界区时应立即释放所占有的CPU，以免陷入“忙等”（进程在占有CPU的同时又一直等待），保证其他可执行的进程获得CPU运行。</p>
<h4 id="互斥访问临界资源的办法"><a href="#互斥访问临界资源的办法" class="headerlink" title="互斥访问临界资源的办法"></a>互斥访问临界资源的办法</h4><h5 id="依靠软件"><a href="#依靠软件" class="headerlink" title="依靠软件"></a>依靠软件</h5><p>三标志进程互斥算法</p>
<p>基本思想是：设置3个标志T1、T2和T，其中T1和T2的作用与两标志进程互斥算法相同，而T是一个公共标志，用来表示允许进入临界区的进程标号；若进程希望进入临界区，则先设置自己的标志Ti（i=1, 2），然后再检测公共标志T，若T等于i（i=1, 2），则表示允许进程Pi（i=1, 2）进入临界区。</p>
<table>
<thead>
<tr>
<th align="left">进程P1：</th>
<th>进程P2：</th>
</tr>
</thead>
<tbody><tr>
<td align="left">…  <br>T1=1;   //设置P1在临界区标志  <br>T=2;   //允许P2进入临界区 <br> while(T2==1&amp;&amp;T==2);  <br>临界区; <br/> T1=0;   //设置P1不在临界区标志 <br/> …</td>
<td>…  <br/>T2=1;   //设置P2在临界区标志 <br/> T=1;   //允许P1进入临界区 <br/> while(T1==1&amp;&amp;T==1);  <br/>临界区;  <br/>T2=0;   //设置P2不在临界区标志 <br/> …</td>
</tr>
</tbody></table>
<h5 id="依靠系统支持才得以实现的办法"><a href="#依靠系统支持才得以实现的办法" class="headerlink" title="依靠系统支持才得以实现的办法"></a>依靠系统支持才得以实现的办法</h5><h6 id="关中断"><a href="#关中断" class="headerlink" title="关中断"></a>关中断</h6><h6 id="用加锁和开锁原语解决进程互斥的模型-原语固化"><a href="#用加锁和开锁原语解决进程互斥的模型-原语固化" class="headerlink" title="用加锁和开锁原语解决进程互斥的模型\原语固化"></a>用加锁和开锁原语解决进程互斥的模型\原语固化</h6><p>原语（primitives）</p>
<p>操作系统层面上的“原语”（比如 write 之类的系统调用）对程序员来讲的确是不可分割的最小单位，但是这写系统调用本身还是用好几句汇编语句组成的（对于 Linux 来说是 C 语言）。可能有人要说到了机器代码这一级就不能再分了，但事实上一条机器指令也是由好几个组合逻辑信号构成的。同样的道理，控制信号也不过是无数电子在器件内部漂移的结果。</p>
<p>因此定义“原语”的前提是观察者所处的位置。一旦规定了观察者的位置和观察的角度，比如就在操作系统的这层上，read，wirte，wait这些个系统调用自然就是最“原始”的词汇，这也是为什么“原语”会在操作系统中频繁出现的缘故。</p>
<h6 id="信号量法"><a href="#信号量法" class="headerlink" title="信号量法"></a>信号量法</h6><p>信号量的物理意义</p>
<p>信号量的值n</p>
<p>当n&gt;=0时，代表可用资源的数量(即当前所剩的未分配资源数量)</p>
<p>当n&lt;0时，其绝对值等于队列的长度，为因暂时无这种资源可用，而进入阻塞状态等待的线程数量。</p>
<p>P操作：申请资源，并有可能阻塞调用进程</p>
<p>V操作：释放资源，必定唤醒一个阻塞进程(如果有的话)</p>
<p><strong>信号量跟锁的区别</strong></p>
<p>两个卫生间，需要两把锁</p>
<p>而用信号量的话，用一个信号量就行了</p>
<p>锁的lock操作是忙等</p>
<p>信号量的p操作不会忙等，而会阻塞。</p>
<p><strong>生产者－消费者问题</strong></p>
<p>一个有限空间的共享缓冲区，负责存放货物</p>
<p>生产者向缓冲区中放物品，缓冲区满则不能放</p>
<p>消费者从缓冲区中拿物品，缓冲区空则不能拿</p>
<img src="  images\image-20210622012129785.png" alt="image-20210622012129785" style="zoom:50%;" />

<p>生产者消费者问题的几种情况</p>
<p>①1个生产者、1个消费者共享1个单元缓冲区</p>
<table>
<thead>
<tr>
<th>Semaphore  空格子(1); <br/> Semaphore  装点心的格子(0);</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>生产者</td>
<td>消费者</td>
</tr>
<tr>
<td>while (true) {  <br/>   制作一个点心   <br/>  空格子.p();     <br/> 放入点心     <br/> 装点心的格子.v(); <br/> }</td>
<td>while (true) {   <br/> 装点心的格子.p();  <br/> 取出点心     <br/> 空格子.v();   <br/>  吃点心 <br/> }</td>
</tr>
</tbody></table>
<img src="  images\image-20210622012630096.png" alt="image-20210622012630096" style="zoom:50%;" />



<p>②1个生产者、1个消费者共享n个单元缓冲区</p>
<table>
<thead>
<tr>
<th>Semaphore  空格子(n); <br/> Semaphore  装点心的格子(0); <br/> Box : array[0..n-1]  of 点心;  int in = 0, out = 0;</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>生产者</td>
<td>消费者</td>
</tr>
<tr>
<td>while (true) {    <br/> 制作一个点心     <br/>空格子.p();    <br/> Box[in] = 点心;        <br/>  in=(in+1) % n;     <br/> 装点心的格子.v(); <br/> }</td>
<td>while (true) { <br/>    装点心的格子.p();    <br/> 点心 = Box[out];    <br/> out=(out+1) % n;    <br/> 空格子.v();    <br/> 吃点心  <br/>}</td>
</tr>
</tbody></table>
<img src="  images\image-20210622012703886.png" alt="image-20210622012703886" style="zoom:50%;" />



<p>③m个生产者、k个消费者共享n个单元缓冲区</p>
<table>
<thead>
<tr>
<th>Semaphore  空格子(n);  <br/>Semaphore 装点心的格子(0); <br/> Semaphore  mutex(1);  // mutual  exclusive  Box : array[0..n-1]  of 点心;  int in = 0, out = 0;</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>生产者</td>
<td>消费者</td>
</tr>
<tr>
<td>while (true) {  <br/>   制作一个点心     <br/>空格子.p();     <br/>mutex.p();    <br/> Box[in]  = 点心;       <br/>   in=(in+1) % n;    <br/> mutex.v();     <br/> 装点心的格子.v(); <br/> }</td>
<td>while (true) {   <br/>  装点心的格子.p();  <br/>   mutex.p();    <br/> 点心 = Box[out];   <br/>  out=(out+1) % n;  <br/>   mutex.v();    <br/> 空格子.v();    <br/> 吃点心  <br/>}</td>
</tr>
</tbody></table>
<img src="  images\image-20210622012741756.png" alt="image-20210622012741756" style="zoom:50%;" />

<table>
<thead>
<tr>
<th>Semaphore  空格子(n);  <br/>Semaphore 装点心的格子(0);  <br/>Semaphore  mutexForIn(1), mutexForOut(1);  <br/>Box : array[0..n-1]  of 点心;  int in = 0, out = 0;</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>生产者</td>
<td>消费者</td>
</tr>
<tr>
<td>while (true) {     <br/>制作一个点心     <br/>空格子.p();    <br/> mutexForIn.p();     <br/>Box[in]  = 点心;       <br/>   in=(in+1) % n;   <br/>  mutexForIn.v();    <br/>  装点心的格子.v(); <br/> }</td>
<td>while (true) {    <br/> 装点心的格子.p();  <br/>   mutexForOut.p();  <br/>   点心 = Box[out];    <br/> out=(out+1) % n;   <br/> mutexForOut.v();     <br/>空格子.v();    <br/> 吃点心 <br/> }</td>
</tr>
</tbody></table>
<img src="  images\image-20210622012852313.png" alt="image-20210622012852313" style="zoom: 45%;" />





<h6 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h6><p>复习不完了。。</p>
<p>好多呀。。。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sharp-v.github.io/2021/06/18/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sharp-v">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sharp-v's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/18/hello-world/" class="post-title-link" itemprop="url">整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-18 21:44:18" itemprop="dateCreated datePublished" datetime="2021-06-18T21:44:18+08:00">2021-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-21 09:15:12" itemprop="dateModified" datetime="2021-06-21T09:15:12+08:00">2021-06-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>存放并整理一些知识点。</p>
<p>markdown是一种简洁的排版文件类型，<a target="_blank" rel="noopener" href="https://markdown.com.cn/">markdown 语法</a></p>
<p>npm 更换镜像源(such as install vue)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">sharp-v</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sharp-v</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
